(-) fitCode (returned from bdotsFit) (located in bdotsFitter function)
Allows for subset based on condition fit
  ## Fail Code ==
  # + 1 - 0.8 < R2 < 0.95
  # + 2 - R2 < 0.8
  # + 3 - AR1 == FALSE
  ## This gives
  # 0 - AR1 TRUE and R2 > .95
  # 1 - AR1 TRUE and 0.8 < R2 < 0.95
  # 2 - AR1 TRUE and R2 < 0.8
  # 3 - AR1 FALSE and R2 > .95
  # 4 (3 + 1) - AR1 FALSE and 0.8 < R2 < 0.85
  # 5 (3 + 2) - AR1 FALSE and R2 < 0.8
  # 6 indicates model did not fit at all

(-) For bdotsObject, the fist is stored as a length one list with gnls object inside

(-) Bob made note to hide 0.9 for cor default from user, but allow to be specified with dots

(-) In bdotsBoot, for the while loop determining PD matrix, have escape hatch and issue warning if fit without correlation in bivariate normal

(-) value of rho is implied by argument to `cor`. If cor == TRUE rho <- 0.9 (or user input). If cor = FALSE, rho = 0

(?) sys.nframe() returns number of frames from global env. How does this work in parellel? Fuck, I've got something sexy for that.

(-) should make doubleGauss(concave = TRUE), logistic(), poly(n = N) actual functions that return everything needed for fitting parameters based on input of data. This would keep the model/parameter fitting fullyl specified by this function. If we assume it has a specified form, anybody could create their own to do the same.

(-) print.bdots <- wrapper around print.data.table. Take the bdotsObj, hide the rows that are marked as 'removed' and only print out the remaining ones

(-) add model coefficients to bdotsObj output

Ideas:
- Add argument for minimum R2 (i.e., if R2 < 0.8, drop auto correlation and try again)
