(-) fitCode (returned from bdotsFit) (located in bdotsFitter function)
Allows for subset based on condition fit
  ## Fail Code ==
  # + 1 - 0.8 < R2 < 0.95
  # + 2 - R2 < 0.8
  # + 3 - AR1 == FALSE
  ## This gives
  # 0 - AR1 TRUE and R2 > .95
  # 1 - AR1 TRUE and 0.8 < R2 < 0.95
  # 2 - AR1 TRUE and R2 < 0.8
  # 3 - AR1 FALSE and R2 > .95
  # 4 (3 + 1) - AR1 FALSE and 0.8 < R2 < 0.85
  # 5 (3 + 2) - AR1 FALSE and R2 < 0.8
  # 6 indicates model did not fit at all

(-) For bdotsObject, the fist is stored as a length one list with gnls object inside

(-) Bob made note to hide 0.9 for cor default from user, but allow to be specified with dots

(-) In bdotsBoot, for the while loop determining PD matrix, have escape hatch and issue warning if fit without correlation in bivariate normal

(-) value of rho is implied by argument to `cor`. If cor == TRUE rho <- 0.9 (or user input). If cor = FALSE, rho = 0

(?) sys.nframe() returns number of frames from global env. How does this work in parellel? Fuck, I've got something sexy for that.

(-) should make doubleGauss(concave = TRUE), logistic(), poly(n = N) actual functions that return everything needed for fitting parameters based on input of data. This would keep the model/parameter fitting fullyl specified by this function. If we assume it has a specified form, anybody could create their own to do the same. We can put the ones we built into their own R files (all gauss functions, all logistic), but then document what it is, and what it requires

Say they pass `call = doubleGauss(concave = TRUE)`, we can then take this and do `call[[data]] <- data` to add what is needed to these functions. It will also make passing shit to clusterExport cleaner. FUCK, we can do that from the beginning. Pass in rho, cor, whatever else we need to do so

(-) print.bdots <- wrapper around print.data.table. Take the bdotsObj, hide the rows that are marked as 'removed' and only print out the remaining ones

(-) add model coefficients to bdotsObj output <- I don't like this just being appended. I think it would be far cleaner as a matrix stored in attributes
-- Note, though, that means I would have to add bdots::`[`. It would also not save them from using subset(bdotsObj, ..., ...). Fuck. Or any of the dplyr things. For now, I'm going to not worry about the refit step.

(-) Can I fit paired group in gnls at same time? By melting DT by group?

(-) https://stackoverflow.com/questions/27547548/solving-error-message-step-halving-factor-reduced-below-minimum-in-nls-step-a

(-) For fitting multiple curves simultaneously, this seems to confirm my original intuitiion:
https://stackoverflow.com/questions/27405484/2-curves-simultaneous-nonlinear-regression

(-) (!) LOL. I can rewrite bdotsFit and bdotsFitter so that bdotsFitter is the "base case" and I can otherwise just call bdotsFit on itself. That removes an entire function from this package! ARHARHAHRA!!!!! (it's in parallel  because there are only two cases 1) it's a single observation or 2) its multiple, and then when parApply that shit

(-) instead of checking class  "bdotsObj", make function isBdots. That way, if something is lost while transforming it, we can still recover

(-) Should rewrite split.data.table for split.bdotsObj

Ideas:
- Add argument for minimum R2 (i.e., if R2 < 0.8, drop auto correlation and try again)
